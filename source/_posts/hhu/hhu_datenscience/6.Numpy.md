---
title: Daten_Science æ€»ç»“-6
date: 2022-08-12 22:44:45
categories : 
- hhu 
- Daten_Science
tags:
password: cocovv
---


# 6. Numpy
In diesem kurzen Abschnitt lernen wir die wesentlichen Ideen bei Numpy kennen. Eine lÃ¤ngere und bessere (und englischere) Fassung davon sind die Numpy fundamentals im Numpy User Guide, die Sie am besten im Anschluss Ã¼berfliegen sollten. Ein richtiges (und sehr gutes) Lehrbuch fÃ¼r alle, die mit Python vertraut sind (und als das betrachten wir uns zu diesem Punkt der Vorlesung) ist Nicolas Rougierâ€™s From Python to Numpy, wo fÃ¼r uns zunÃ¤chst Kapitel 3 relevant ist.

Kurz lÃ¤sst sich sagen, dass mit Numpy Array-orientierte Programmierung (auch: Vektorisierung) in Python mÃ¶glich wird.

## 6.1. Arrays
Numeric Python (Numpy) wird meist als np abgekÃ¼rzt importiert:

# 6. Numpy
åœ¨è¿™ä¸ªå°èŠ‚ä¸­ï¼Œæˆ‘ä»¬äº†è§£äº†Numpyçš„ä¸»è¦æ€æƒ³ã€‚ä¸€ä¸ªæ›´é•¿ã€æ›´å¥½ï¼ˆä¹Ÿæ›´è‹±æ–‡ï¼‰çš„ç‰ˆæœ¬æ˜¯Numpyç”¨æˆ·æŒ‡å—ä¸­çš„NumpyåŸºç¡€çŸ¥è¯†ï¼Œæœ€å¥½æ˜¯äº‹åç•¥è¯»ä¸€ä¸‹ã€‚å¯¹äºä»»ä½•ç†Ÿæ‚‰Pythonçš„äººæ¥è¯´ï¼Œä¸€æœ¬åˆé€‚çš„ï¼ˆä¹Ÿæ˜¯éå¸¸å¥½çš„ï¼‰æ•™ç§‘ä¹¦ï¼ˆåœ¨è®²åº§çš„è¿™ä¸€ç‚¹ä¸Šæˆ‘ä»¬è®¤ä¸ºè‡ªå·±æ˜¯è¿™æ ·çš„ï¼‰æ˜¯Nicolas Rougierçš„ã€Šä»Pythonåˆ°Numpyã€‹ï¼Œå…¶ä¸­ç¬¬ä¸‰ç« ä¸æˆ‘ä»¬é¦–å…ˆç›¸å…³ã€‚

ç®€è€Œè¨€ä¹‹ï¼Œå¯ä»¥è¯´Numpyä½¿Pythonä¸­é¢å‘æ•°ç»„çš„ç¼–ç¨‹ï¼ˆä¹Ÿå°±æ˜¯ï¼šçŸ¢é‡åŒ–ï¼‰æˆä¸ºå¯èƒ½ã€‚

## 6.1 æ•°ç»„
Numeric Python (Numpy)é€šå¸¸è¢«å¯¼å…¥ç¼©å†™ä¸ºnpã€‚

```python
```
import numpy as np
sample = np.random.random(10)
print(sample)
print(type(sample))
sample
```

```python
[0.71853665 0.11280385 0.89256017 0.04671813 0.01798126 0.67993356
 0.10616332 0.45492242 0.38529958 0.5457223 ]
<class 'numpy.ndarray'>
```

```python
array([0.71853665, 0.11280385, 0.89256017, 0.04671813, 0.01798126,
       0.67993356, 0.10616332, 0.45492242, 0.38529958, 0.5457223 ])
```

Viele nÃ¼tzliche Hilfsfunktionen sind in Numpy enthalten, die wiederum Numpy-eigene Datenstrukturen (den Array) verarbeiten.

```python
sample = np.random.randint(low=0, high=10, size=5000)
print("mean    =", np.mean(sample),   "\nexpected=", 9/2)
print("stdÂ²    =", np.std(sample)**2, "\nvariance=", 99/12)
```

```python
mean    = 4.465 
expected= 4.5
stdÂ²    = 8.012775 
variance= 8.25
```
Es gibt auch eine arange-Methode, sie erzeugt aber keine Range-Objekte in Numpy:



```python
myRange = np.arange(1, 7)
print(myRange, type(myRange), myRange.dtype)
myRange
```

```python
[1 2 3 4 5 6] <class 'numpy.ndarray'> int64
```

```python
array([1, 2, 3, 4, 5, 6])
```
Der Numpy-Array ndarray trÃ¤gt im Gegensatz zur Python-Liste einen festen Datentyp, den alle Elemente gemeinsam haben. Das kÃ¶nnen alle Numpy-datatypes (dtypes) sein, z.B. double (kompatibel mit dem Python-float) oder float32 (auf den meisten Plattformen kompatibel mit dem C-float) oder long (kompatibel mit dem Python-int).

Numpyæ•°ç»„ndarrayä¸Python listä¸åŒï¼Œå®ƒå¸¦æœ‰ä¸€ä¸ªå›ºå®šçš„æ•°æ®ç±»å‹ï¼Œæ‰€æœ‰å…ƒç´ éƒ½æœ‰å…±åŒçš„ç‰¹ç‚¹ã€‚è¿™å¯ä»¥æ˜¯æ‰€æœ‰çš„Numpyæ•°æ®ç±»å‹ï¼ˆdtypesï¼‰ï¼Œä¾‹å¦‚doubleï¼ˆä¸Python floatå…¼å®¹ï¼‰æˆ–float32ï¼ˆä¸å¤§å¤šæ•°å¹³å°ä¸Šçš„C floatå…¼å®¹ï¼‰æˆ–longï¼ˆä¸Python-intå…¼å®¹ï¼‰ã€‚

```python
import timeit
ordinary_list = [1,2,3,4,5,6,5,4,3,2,1]*10
def sort_array(dtype):
    a = np.array(ordinary_list, dtype)
    a.sort()
print(timeit.timeit(lambda : sort_array(np.byte)))
print(timeit.timeit(lambda : sort_array(np.float64)))
```

```python
6.738261688995408
8.536722582997754
```
Dadurch, dass der Datentyp prÃ¤zise bekannt ist, kann Numpy darauf optimierte Algorithmen, direkt in C implementiert, verwenden.

Was es noch fÃ¼r dtypes gibt und wie sie eingesetzt werden, kÃ¶nnen wir der Dokumentation entnehmen:

å› ä¸ºæ•°æ®ç±»å‹æ˜¯ç²¾ç¡®çŸ¥é“çš„ï¼ŒNumpyå¯ä»¥ä½¿ç”¨ä¸ºå…¶ä¼˜åŒ–çš„ç®—æ³•ï¼Œç›´æ¥ç”¨Cè¯­è¨€å®ç°ã€‚
è¿˜æœ‰å“ªäº›å…¶ä»–çš„dtypeså­˜åœ¨ä»¥åŠå¦‚ä½•ä½¿ç”¨å®ƒä»¬ï¼Œå¯ä»¥åœ¨æ–‡æ¡£ä¸­æ‰¾åˆ°ã€‚

â€Structured Arraysâ€œ

â€Data typesâ€œ in den â€Numpy fundamentalsâ€œ

â€Scalarsâ€œ

â€Data type objects (dtype)â€œ

â€numpy.dtypeâ€œ

Es gibt noch mehr Wege, Arrays zu erzeugen, auÃŸer mit arange oder durch konvertieren einer Python-Sequenz. Z.B. lÃ¤sst sich mit ones ein Array gefÃ¼llt mit  und mit zeros ein Array gefÃ¼llt mit  erzeugen.

Der Grund dafÃ¼r, dass das Array den Namen ndarray trÃ¤gt, ist, dass es fÃ¼r ``-dimensional arrayâ€˜â€˜ steht. Wenn man in Python eine Matrix speichern mÃ¶chte, wÃ¼rde man das als Liste der Zeilenvektoren (oder der Spaltenvektoren) tun, etwa

é™¤äº†ä½¿ç”¨rangeæˆ–è½¬æ¢Pythonåºåˆ—ï¼Œè¿˜æœ‰æ›´å¤šçš„æ–¹æ³•æ¥åˆ›å»ºæ•°ç»„ã€‚ä¾‹å¦‚ï¼Œä½ å¯ä»¥ç”¨1æ¥åˆ›å»ºä¸€ä¸ªå……æ»¡1çš„æ•°ç»„ï¼Œç”¨0æ¥åˆ›å»ºä¸€ä¸ªå……æ»¡0çš„æ•°ç»„ã€‚
æ•°ç»„ä¹‹æ‰€ä»¥è¢«å‘½åä¸ºndarrayï¼Œæ˜¯å› ä¸ºå®ƒä»£è¡¨ç€ "ğ‘›-ç»´æ•°ç»„"ã€‚å¦‚æœä½ æƒ³åœ¨Pythonä¸­å­˜å‚¨ä¸€ä¸ªçŸ©é˜µï¼Œä½ å¯ä»¥æŠŠå®ƒä½œä¸ºä¸€ä¸ªè¡Œå‘é‡(æˆ–åˆ—å‘é‡)çš„åˆ—è¡¨ï¼Œä¾‹å¦‚

```python
matrix = [[1,0,0], [0,1,0], [0,0,1]]  # Einheitsmatrix
print(matrix, type(matrix))
quarkix = matrix      # eine Kopie
print(quarkix[0][0])
quarkix[0][0] = 0     # wir Ã¤ndern den oberen linken Eintrag
print(matrix[0][0])
```

```python
[[1, 0, 0], [0, 1, 0], [0, 0, 1]] <class 'list'>
1
0
```
Daran sehen wir ein Problem: Python behandelt unsere Matrix wie eine Liste (so haben wir es ja auch hingeschrieben), also wird beim kopieren der Liste der Inhalt (die Zeilenvektoren) nicht mitkopiert (sondern nur die Pointer darauf).

ç”±æ­¤æˆ‘ä»¬çœ‹åˆ°ä¸€ä¸ªé—®é¢˜ï¼šPython æŠŠæˆ‘ä»¬çš„çŸ©é˜µå½“ä½œä¸€ä¸ªåˆ—è¡¨ (æˆ‘ä»¬å°±æ˜¯è¿™æ ·å†™çš„)ï¼Œæ‰€ä»¥å½“å¤åˆ¶åˆ—è¡¨æ—¶ï¼Œå†…å®¹ (è¡Œå‘é‡) æ²¡æœ‰è¢«å¤åˆ¶ (è€Œåªæ˜¯æŒ‡å‘å®ƒçš„æŒ‡é’ˆ)ã€‚

```python
npmatrix = np.identity(3, int)  # Einheitsmatrix
print(npmatrix, type(npmatrix))
npquarkix = npmatrix[:]
print(npquarkix[0][0])
npquarkix[0][0] = 2     # wir Ã¤ndern den oberen linken Eintrag
print(npmatrix[0][0])
# Mit einer echten Kopie wÃ¤re das nicht passiert:
real_copy = npmatrix.copy()
real_copy[0][0] = 1
assert npmatrix[0][0] != 1
```

```python
[[1 0 0]
 [0 1 0]
 [0 0 1]] <class 'numpy.ndarray'>
1
2
```
Es ist wichtig, festzustellen, dass der Numpy-Array das gleiche Verhalten an den Tag legt wie unsere Python-Liste-von-Listen. Wir kÃ¶nnen gleich damit indizieren und slicen, und es gibt das gleiche Problem beim Kopieren Ã¼ber die Slicing-Syntax.

Der shape-Parameter sagt uns, welche Form unser Numpy-Array hat. Dabei handelt es sich um ein -Tupel, wobei d die 2Dimension ist. Eine Matrix ist 1-dimensional, ein Vektor -dimensional und ein Skalar 0-dimensional.

éœ€è¦æ³¨æ„çš„æ˜¯ï¼ŒNumpyæ•°ç»„çš„è¡Œä¸ºä¸æˆ‘ä»¬çš„Python list-of-listsç›¸åŒã€‚æˆ‘ä»¬å¯ä»¥é©¬ä¸Šç”¨å®ƒè¿›è¡Œç´¢å¼•å’Œåˆ‡ç‰‡ï¼Œè€Œé€šè¿‡åˆ‡ç‰‡è¯­æ³•è¿›è¡Œå¤åˆ¶ä¹Ÿå­˜åœ¨åŒæ ·çš„é—®é¢˜ã€‚
shapeå‚æ•°å‘Šè¯‰æˆ‘ä»¬æˆ‘ä»¬çš„numpyæ•°ç»„æ˜¯ä»€ä¹ˆå½¢çŠ¶ã€‚è¿™æ˜¯ä¸€ä¸ªğ‘‘å…ƒç»„ï¼Œå…¶ä¸­ğ‘‘æ˜¯å°ºå¯¸ã€‚çŸ©é˜µæ˜¯2ç»´çš„ï¼ŒçŸ¢é‡æ˜¯1ç»´çš„ï¼Œæ ‡é‡æ˜¯0ç»´çš„ã€‚

```python
print(npmatrix.shape)
print(npmatrix[0], npmatrix[0].shape)
print(npmatrix[0][0], npmatrix[0][0].shape)
```

```python
(3, 3)
[2 0 0] (3,)
2 ()

```
In Numpy kann man noch etwas feiner slicen. Die Allgemeine Syntax ist [start:stop:step, ..] wobei man mit dem Komma getrennt Ã¼ber die Achsen geht. Ein zweidimensionaler Array hat zwei Achsen, wobei Achse 0 von oben nach unten und Achse 1 von links nach rechts indiziert ist. WÃ¤hrend â€stepâ€œ auch mit Python-Listen funktioniert, ist das indizieren mit mehreren Achsen eine SpezialitÃ¤t von Numpy

åœ¨Numpyä¸­ï¼Œä½ å¯ä»¥åˆ‡å¾—æ›´ç»†ã€‚ä¸€èˆ¬çš„è¯­æ³•æ˜¯[start:stop:step, ...]ï¼Œå…¶ä¸­å„è½´ä¹‹é—´ç”¨é€—å·åˆ†éš”ã€‚ä¸€ä¸ªäºŒç»´æ•°ç»„æœ‰ä¸¤ä¸ªè½´ï¼Œè½´0çš„ç´¢å¼•ä»ä¸Šåˆ°ä¸‹ï¼Œè½´1ä»å·¦åˆ°å³ã€‚è™½ç„¶ "step "ä¹Ÿé€‚ç”¨äºPythonåˆ—è¡¨ï¼Œä½†å¤šè½´çš„ç´¢å¼•æ˜¯Numpyçš„ä¸€ä¸ªç‰¹è‰²ã€‚

```python
matrix = list(range(1,10))
npmatrix = np.array(matrix)
print("not in shape:", npmatrix)
npmatrix.shape = (3,3)
print("in much better shape:\n"+ str(npmatrix))
print("Zeilenvektor Zeile 0:", npmatrix[0])
print("Spaltenvektor Spalte 0:", npmatrix[:,0])
print("Spalten 1-2:\n"+ str(npmatrix[:,1:]))
print("Alle Zeilen, Schrittweite 2\n"+ str(npmatrix[0::2]))
```

```python
not in shape: [1 2 3 4 5 6 7 8 9]
in much better shape:
[[1 2 3]
 [4 5 6]
 [7 8 9]]
Zeilenvektor Zeile 0: [1 2 3]
Spaltenvektor Spalte 0: [1 4 7]
Spalten 1-2:
[[2 3]
 [5 6]
 [8 9]]
Alle Zeilen, Schrittweite 2
[[1 2 3]
 [7 8 9]]
```
In klassischem Python-Code wÃ¼rden wir auf einen Eintrag einer Matrix zugreifen mit matrix[x][y], und das funktioniert so auch in Numpy. Allerdings wird dabei zunÃ¤chst ein weiteres Listenobjekt matrix[x] erzeugt (beim Slicing auch zusÃ¤tzlicher Speicher dafÃ¼r belegt) und dann darauf [y] aufgerufen. Es ist daher grundsÃ¤tzlich effizienter, direkt Numpyâ€™s [x,y] zu verwenden.

Numpy erzeugt bewusst keine Kopien beim Slicing, sondern nur eine andere Sichtweise auf den gleichen Speicherbereich (daher auch das oben beobachtete Verhalten bei [:]). Ob zwei Arrays auf den gleichen Speicherbereich verweisen, lÃ¤sst sich mit np.may_share_memory prÃ¼fen. Dabei bedeutet ein positives Ergebnis keineswegs, dass die Arrays voneinander abhÃ¤ngig sind - so verweisen die erste und die zweite Spalte einer Matrix auch auf den gleichen Speicherbereich, nÃ¤mlich die ganze Matrix. Wenn man nun einen der beiden Vektoren Ã¤ndert, bleibt der andere unverÃ¤ndert - die ganze Matrix aber Ã¤ndert sich mit.

åœ¨ç»å…¸çš„Pythonä»£ç ä¸­ï¼Œæˆ‘ä»¬ä¼šç”¨matrix[x][y]æ¥è®¿é—®çŸ©é˜µçš„ä¸€ä¸ªæ¡ç›®ï¼Œè¿™åœ¨Numpyä¸­ä¹Ÿæ˜¯å¯è¡Œçš„ã€‚ç„¶è€Œï¼Œé¦–å…ˆåˆ›å»ºäº†å¦ä¸€ä¸ªåˆ—è¡¨å¯¹è±¡çŸ©é˜µ[x]ï¼ˆåœ¨åˆ‡ç‰‡ä¸­ä¹Ÿä¸ºå…¶ä½¿ç”¨äº†é¢å¤–çš„å†…å­˜ï¼‰ï¼Œç„¶åå¯¹å…¶è°ƒç”¨[y]ã€‚å› æ­¤ï¼Œä¸€èˆ¬æ¥è¯´ï¼Œç›´æ¥ä½¿ç”¨Numpyçš„[x,y]ä¼šæ›´æœ‰æ•ˆç‡ã€‚
Numpyåœ¨åˆ‡åˆ†æ—¶æ•…æ„ä¸åˆ›å»ºå‰¯æœ¬ï¼Œè€Œåªæ˜¯åˆ›å»ºåŒä¸€å†…å­˜åŒºåŸŸçš„ä¸åŒè§†å›¾ï¼ˆå› æ­¤ä¸Šé¢è§‚å¯Ÿåˆ°çš„[:]çš„è¡Œä¸ºï¼‰ã€‚ä¸¤ä¸ªæ•°ç»„æ˜¯å¦å¼•ç”¨äº†ç›¸åŒçš„å†…å­˜åŒºåŸŸå¯ä»¥ç”¨np.may_share_memoryæ¥æ£€æŸ¥ã€‚æ­£çš„ç»“æœå¹¶ä¸æ„å‘³ç€æ•°ç»„ä¹‹é—´æ˜¯ç›¸äº’ä¾èµ–çš„--çŸ©é˜µçš„ç¬¬ä¸€åˆ—å’Œç¬¬äºŒåˆ—ä¹Ÿæ˜¯æŒ‡åŒä¸€ä¸ªå†…å­˜åŒºåŸŸï¼Œå³æ•´ä¸ªçŸ©é˜µã€‚å¦‚æœä¸¤ä¸ªå‘é‡ä¸­çš„ä¸€ä¸ªè¢«æ”¹å˜ï¼Œå¦ä¸€ä¸ªä¿æŒä¸å˜--ä½†æ•´ä¸ªçŸ©é˜µä¹Ÿéšä¹‹æ”¹å˜ã€‚
```python
npmatrix = np.array(list(range(1,10))).reshape(3,3)
candidates = (npmatrix[0::2], npmatrix[1])
print("May share memory (but actually don't):",
      candidates, np.may_share_memory(*candidates))
print(type([0,0,0]))     # vor der Zuweisung
npmatrix[1] = [0,0,0]
print(type(npmatrix[1])) # nach der Zuweisung
print(npmatrix)          # die ganze Matrix ist wie verÃ¤ndert
```

```python
May share memory (but actually don't): (array([[1, 2, 3],
       [7, 8, 9]]), array([4, 5, 6])) True
<class 'list'>
<class 'numpy.ndarray'>
[[1 2 3]
 [0 0 0]
 [7 8 9]]
```
AusfÃ¼hrliche Informationen zum Slicing und Indizieren liefert die Dokumentation.

6.2. Broadcasting
WÃ¤hrend fÃ¼r Python-Listen der Additionsoperator die Listenkonkatenation ist, und damit die Multiplikation von Listen mit Skalaren definiert ist, ist die Multiplikation von zwei Listen undefiniert. FÃ¼r Numpy-Arrays sind deutlich mehr arithmetische Operationen verfÃ¼gbar:

å…³äºåˆ‡ç‰‡å’Œç´¢å¼•çš„è¯¦ç»†ä¿¡æ¯åœ¨æ–‡æ¡£ä¸­æä¾›ã€‚
6.2 å¹¿æ’­
è™½ç„¶å¯¹äº Python çš„åˆ—è¡¨æ¥è¯´ï¼ŒåŠ æ³•è¿ç®—ç¬¦æ˜¯åˆ—è¡¨è¿æ¥ï¼Œå› æ­¤åˆ—è¡¨ä¸æ ‡é‡çš„ä¹˜æ³•æ˜¯å®šä¹‰çš„ï¼Œä½†ä¸¤ä¸ªåˆ—è¡¨çš„ä¹˜æ³•æ˜¯æœªå®šä¹‰çš„ã€‚å¯¹äºNumpyæ•°ç»„ï¼Œå¯ç”¨çš„ç®—æœ¯æ“ä½œæ˜æ˜¾å¢å¤šã€‚
```python
E = np.identity(3, int)
print(E, "= E")
A = np.ones((3,3), int)
A[0] = [0,0,0]
print(A, "= A")
print(E + A, "= E + A")
print(E * A, "= EA")
print((E+A)**2, "= (E+A)(E+A)")
```

```python
[[1 0 0]
 [0 1 0]
 [0 0 1]] = E
[[0 0 0]
 [1 1 1]
 [1 1 1]] = A
[[1 0 0]
 [1 2 1]
 [1 1 2]] = E + A
[[0 0 0]
 [0 1 0]
 [0 0 1]] = EA
[[1 0 0]
 [1 4 1]
 [1 1 4]] = (E+A)(E+A)
```
Wenn man das aufmerksam nachverfolgt, stellt man fest, dass diese Rechnungen keine Matrizenmultiplikationen sind, sondern schlicht elementweise erfolgt sind - so sind die Operationen auf Arrays definiert. Besonders tÃ¼ckisch ist dies:

å¦‚æœä½ ä»”ç»†è¿½é—®ï¼Œä½ ä¼šæ„è¯†åˆ°è¿™äº›è®¡ç®—å¹¶ä¸æ˜¯çŸ©é˜µä¹˜æ³•ï¼Œè€Œæ˜¯ç®€å•çš„å…ƒç´ ä¹˜æ³•--è¿™å°±æ˜¯å¯¹æ•°ç»„çš„æ“ä½œçš„å®šä¹‰ã€‚è¿™æ˜¯ç‰¹åˆ«æ£˜æ‰‹çš„é—®é¢˜ã€‚
```python
v = np.ones(3, int)
print(v, "= v")
print(A*v, "= A*v (aber nicht die Matrixmultiplikation)")
```

```python
[1 1 1] = v
[[0 0 0]
 [1 1 1]
 [1 1 1]] = A*v (aber nicht die Matrixmultiplikation)
```
Um explizit mit MatrizenkalkÃ¼l zu rechnen, hat man frÃ¼her den Numpy-Datentyp matrix verwendet, aber dieser ist als deprecated (veraltet) markiert und wird in zukÃ¼nftigen Numpy-Versionen abgeschafft. Heutzutage nutzt man die Methode np.matmul oder den Infix-Operator @.

ä¸ºäº†æ˜ç¡®åœ°ä½¿ç”¨çŸ©é˜µè®¡ç®—ï¼Œäººä»¬æ›¾ç»ä½¿ç”¨Numpyçš„æ•°æ®ç±»å‹matrixï¼Œä½†è¿™å·²è¢«æ ‡è®°ä¸ºåºŸå¼ƒï¼Œåœ¨æœªæ¥çš„Numpyç‰ˆæœ¬ä¸­ä¼šè¢«åºŸé™¤ã€‚ç°åœ¨äººä»¬ä½¿ç”¨np.matmulæ–¹æ³•æˆ–infixè¿ç®—ç¬¦@ã€‚

```python
print(np.matmul(A,v))
print(A@v)
```

```python
[0 3 3]
[0 3 3]
```
FÃ¼r viele Probleme ist es sehr hilfreich, nicht den MatrizenkalkÃ¼l zu verwenden, sondern elementweise arithmetische Operationen auszufÃ¼hren. Broadcasting ist ein Mechanismus, der diesen elementweisen KalkÃ¼l etwas praktischer macht. So ist die Operation (-array) * (-Vektor) automatisch interpretiert, indem der -Vektor -fach kopiert wird, sodass die Multiplikation einer jeden Zeile des linken Arrays mit dem Vektor (elementweise) durchgefÃ¼hrt wird.

Dazu ist es wirklich hilfreich, einmal die Dokumentation zu Ã¼berfliegen.

## 6.3. ufuncs
ufunc steht fÃ¼r â€universal functionâ€œ und bezeichnet eine Methode, die auf Numpy Arrays vektorisiert laufen kann.

Mit jeder ufunc lÃ¤sst sich z.B. reduce durchfÃ¼hren, wo entlang einer Achse des Arrays die ufunc auf die resultierenden kleineren Arrays angewandt wird.

Um selbst eine ufunc zu schreiben, muss man C-Code programmieren oder aber einen Wrapper um eine Python-Methode legen.

Es lohnt sich, einen kurzen Blick auf alle bereits definierten ufuncs zu werfen: Available ufuncs

å¯¹äºè®¸å¤šé—®é¢˜æ¥è¯´ï¼Œä¸ä½¿ç”¨çŸ©é˜µå¾®ç§¯åˆ†ï¼Œè€Œæ˜¯è¿›è¡Œå…ƒç´ ç®—æœ¯è¿ç®—æ˜¯éå¸¸æœ‰å¸®åŠ©çš„ã€‚å¹¿æ’­æ˜¯ä¸€ç§æœºåˆ¶ï¼Œå®ƒä½¿è¿™ç§ä»å…ƒç´ ä¸Šçœ‹çš„è®¡ç®—æ›´å®ç”¨ä¸€äº›ã€‚ä¾‹å¦‚ï¼Œæ“ä½œï¼ˆğ‘›Ã—ğ‘›-æ•°ç»„ï¼‰*ï¼ˆğ‘›-å‘é‡ï¼‰ä¼šè¢«è‡ªåŠ¨è§£é‡Šä¸ºå¤åˆ¶ğ‘›-å‘é‡çš„ ğ‘›å€ï¼Œè¿™æ ·å°±ä¼šå¯¹å·¦è¾¹æ•°ç»„çš„æ¯ä¸€è¡Œè¿›è¡Œå‘é‡ä¹˜æ³•ï¼ˆé€ä¸ªå…ƒç´ ï¼‰ã€‚
å¯¹äºè¿™ä¸€ç‚¹ï¼Œç•¥è¿‡ä¸€æ¬¡æ–‡æ¡£ç¡®å®å¾ˆæœ‰å¸®åŠ©ã€‚
6.3 ufuncs
ufuncæ˜¯ "é€šç”¨å‡½æ•° "çš„æ„æ€ï¼ŒæŒ‡çš„æ˜¯å¯ä»¥åœ¨Numpyæ•°ç»„ä¸Šè¿è¡ŒçŸ¢é‡çš„æ–¹æ³•ã€‚
æ¯ä¸ªufuncå¯ä»¥ç”¨æ¥æ‰§è¡Œä¾‹å¦‚å‡å°‘ï¼Œæ²¿ç€æ•°ç»„çš„ä¸€ä¸ªè½´ï¼Œufuncè¢«åº”ç”¨åˆ°æ‰€äº§ç”Ÿçš„å°æ•°ç»„ã€‚
è¦æƒ³è‡ªå·±å†™ä¸€ä¸ªufuncï¼Œä½ å¿…é¡»ç¼–å†™Cè¯­è¨€ä»£ç ï¼Œå¦åˆ™å°±åœ¨Pythonæ–¹æ³•ä¸ŠåŠ ä¸€ä¸ªåŒ…è£…ã€‚
å€¼å¾—å¿«é€Ÿæµè§ˆä¸€ä¸‹æ‰€æœ‰å·²ç»å®šä¹‰çš„ufuncsã€‚å¯ç”¨çš„ ufuncs
