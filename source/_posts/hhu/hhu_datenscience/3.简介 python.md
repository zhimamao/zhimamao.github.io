---
title: Daten_Science æ€»ç»“-3
date: 2022-08-12 22:44:45
categories : 
- hhu 
- Daten_Science
tags:
password: cocovv
---

# 3. EinfÃ¼hrung in Python


## 3.1. Einordnung

Python hat eine andere Designphilosophie als C, C++, Perl, Lisp, Pascal, aber viele EinflÃ¼sse aus frÃ¼heren Sprachen. Durch einen aktiven Community-Prozess entwickelt sich die Sprache immer weiter.

```
3 Pythonç®€ä»‹
3.1 åˆ†ç±»
Pythonçš„è®¾è®¡ç†å¿µä¸Cã€C++ã€Perlã€Lispã€Pascalä¸åŒï¼Œä½†æœ‰è®¸å¤šæ¥è‡ªæ—©æœŸè¯­è¨€çš„å½±å“ã€‚é€šè¿‡ä¸€ä¸ªç§¯æçš„ç¤¾åŒºè¿›ç¨‹ï¼Œè¯¥è¯­è¨€ç»§ç»­å‘å±•ã€‚
```

Python ist konzipiert als Sprache, die besonders gut lesbar ist, und deren Syntax es Programmierer*innen erlaubt, Konzepte mit weniger Codezeilen auszudrÃ¼cken. Klar: Python ist eine high-level-Programmiersprache, weiter weg von konkreten Maschinenmodellen als C. Ã„hnlich wie Java verwendet Python eine Garbage Collection, sodass man nicht explizit Speicher reservieren und freigeben muss, um Variablen zu belegen.

Mit Python lassen sich funktionale Programmierparadigmen verwenden wie in R oder Haskell, aber auch objektorientierte Paradigmen wie in C# oder Java. Anders als diese Sprachen ist Python zwar auch statisch getypt, aber dynamisch gebunden. So kann ein Variablenname einmal einen String zugewiesen bekommen, direkt danach einen Boolean und danach einen Integer. Wer striktere Typen bevorzugt, kann mittlerweile mit type annotations und speziellen Lintern arbeiten.

```

Pythonè¢«è®¾è®¡æˆä¸€ç§é«˜åº¦å¯è¯»çš„è¯­è¨€ï¼Œå®ƒçš„è¯­æ³•å…è®¸ç¨‹åºå‘˜ç”¨è¾ƒå°‘çš„ä»£ç è¡Œæ¥è¡¨è¾¾æ¦‚å¿µã€‚æ˜¾ç„¶ï¼ŒPythonæ˜¯ä¸€ç§é«˜çº§ç¼–ç¨‹è¯­è¨€ï¼Œæ¯”Cè¯­è¨€ç¦»å…·ä½“çš„æœºå™¨æ¨¡å‹æ›´è¿œã€‚ä¸Javaç±»ä¼¼ï¼ŒPythonä½¿ç”¨åƒåœ¾æ”¶é›†ï¼Œæ‰€ä»¥ä½ ä¸å¿…æ˜ç¡®ä¿ç•™å’Œé‡Šæ”¾å†…å­˜æ¥åˆ†é…å˜é‡ã€‚

ä½¿ç”¨Pythonï¼Œä½ å¯ä»¥ä½¿ç”¨åƒRæˆ–Haskellä¸­çš„å‡½æ•°å¼ç¼–ç¨‹èŒƒå¼ï¼Œä¹Ÿå¯ä»¥ä½¿ç”¨åƒC#æˆ–Javaä¸­çš„é¢å‘å¯¹è±¡èŒƒå¼ã€‚ä¸è¿™äº›è¯­è¨€ä¸åŒï¼ŒPythonä¹Ÿæ˜¯é™æ€ç±»å‹çš„ï¼Œä½†æ˜¯æ˜¯åŠ¨æ€ç»‘å®šçš„ã€‚å› æ­¤ï¼Œä¸€ä¸ªå˜é‡åå¯ä»¥è¢«åˆ†é…ä¸€æ¬¡å­—ç¬¦ä¸²ï¼Œç´§æ¥ç€æ˜¯ä¸€ä¸ªå¸ƒå°”å€¼ï¼Œç„¶åæ˜¯ä¸€ä¸ªæ•´æ•°ã€‚é‚£äº›å–œæ¬¢æ›´ä¸¥æ ¼çš„ç±»å‹çš„äººç°åœ¨å¯ä»¥ç”¨ç±»å‹æ³¨é‡Šå’Œç‰¹æ®Šçš„ä¸´ç•Œç‚¹æ¥å·¥ä½œã€‚
```

Es gibt zwei klassische Arten, Python zu verwenden. Mit einer REPL (read-eval-print loop), Ã¤hnlich einer Shell in der Kommandozeile, lÃ¤sst sich schnell prÃ¼fen, ob kurze Codeschnipsel syntaktisch korrekt sind und sich so verhalten, wie man erwartet. Jede*r Anwender*in von Python sollte sich mit dem Interpreter (also der REPL) vertraut machen.

Durch kompilieren eines Programms (.py) zu Python Bytecode (.pyc) und ausfÃ¼hren des Bytecodes durch Python lassen sich komplexere Aufgaben lÃ¶sen. Aus einer Datei heraus lassen sich andere als Module importieren.

```
æœ‰ä¸¤ç§ç»å…¸çš„æ–¹æ³•æ¥ä½¿ç”¨Pythonã€‚é€šè¿‡REPLï¼ˆè¯»-è¯„-å°å¾ªç¯ï¼‰ï¼Œç±»ä¼¼äºå‘½ä»¤è¡Œä¸Šçš„shellï¼Œä½ å¯ä»¥å¿«é€Ÿæ£€æŸ¥çŸ­çš„ä»£ç ç‰‡æ®µåœ¨è¯­æ³•ä¸Šæ˜¯å¦æ­£ç¡®ï¼Œè¡Œä¸ºæ˜¯å¦ç¬¦åˆé¢„æœŸã€‚æ¯ä¸ª Python ç”¨æˆ·éƒ½åº”è¯¥ç†Ÿæ‚‰è§£é‡Šå™¨ (å³ REPL)ã€‚

é€šè¿‡å°†ç¨‹åº(.py)ç¼–è¯‘æˆPythonå­—èŠ‚ç (.pyc)å¹¶é€šè¿‡Pythonæ‰§è¡Œå­—èŠ‚ç ï¼Œå¯ä»¥è§£å†³æ›´å¤æ‚çš„ä»»åŠ¡ã€‚ä»ä¸€ä¸ªæ–‡ä»¶ï¼Œå…¶ä»–æ–‡ä»¶å¯ä»¥ä½œä¸ºæ¨¡å—å¯¼å…¥ã€‚
```
UrsprÃ¼nglich nutzte man zum HinzufÃ¼gen von Paketen (so heiÃŸen libraries bzw. Bibliotheken bei Python) zu einer Python-Umgebung das Programm pip (Pip Installs Packages). Dieses greift z.B. auf den PyPI (Python Package Index) zurÃ¼ck (analog zum CPAN fÃ¼r Perl, CRAN fÃ¼r R, CTAN fÃ¼r TeX). Erst, wenn man ein Paket heruntergeladen und installiert hat, kann man es in seinen Code importieren und verwenden.

Inzwischen wird im Bereich Data Science meist der Package Manager conda eingesetzt (der auch fÃ¼r R Umgebungen verwendet werden kann). Conda kann AbhÃ¤ngigkeiten zwischen Paketversionen besser verwalten als Pip.

```
æœ€åˆï¼Œpip(Pip Installs Packages)ç¨‹åºè¢«ç”¨æ¥å‘Pythonç¯å¢ƒä¸­æ·»åŠ åŒ…(åº“)ã€‚ä¾‹å¦‚ï¼Œè¿™ä½¿ç”¨äº†PyPIï¼ˆPython Package Indexï¼‰ï¼ˆç±»ä¼¼äºPerlçš„CPANï¼ŒRçš„CRANï¼ŒTeXçš„CTANï¼‰ã€‚åªæœ‰å½“ä½ ä¸‹è½½å¹¶å®‰è£…äº†ä¸€ä¸ªåŒ…ï¼Œä½ æ‰èƒ½å°†å®ƒå¯¼å…¥ä½ çš„ä»£ç ä¸­å¹¶ä½¿ç”¨å®ƒã€‚

åŒæ—¶ï¼Œè½¯ä»¶åŒ…ç®¡ç†å™¨condaï¼ˆä¹Ÿå¯ç”¨äºRç¯å¢ƒï¼‰å¤§å¤šç”¨äºæ•°æ®ç§‘å­¦é¢†åŸŸã€‚Condaå¯ä»¥æ¯”Pipæ›´å¥½åœ°ç®¡ç†è½¯ä»¶åŒ…ç‰ˆæœ¬ä¹‹é—´çš„ä¾èµ–å…³ç³»ã€‚
```
Python wird fÃ¼r den Data Science und Machine Learning Bereich auch in Distributionen angeboten, also gebÃ¼ndelt mit einigen ausgewÃ¤hlten Paketen. FÃ¼r die Ãœbungsaufgaben verwenden wir spÃ¤ter die Distribution Anaconda mit Jupyter Notebooks.

Ein (Jupyter/IPython) Notebook ist ein Dokument, welches aus mehreren Zellen besteht. Jede Zelle kann entweder Text enthalten, Mathematik (LaTeX), oder auch Python-Code, der dann direkt ausgefÃ¼hrt wird (wie eine Browser-gestÃ¼tzte REPL). Implementiert sind diese Notebooks (.ipynb) als JSON-Dokumente.

```
Pythonä¹Ÿåœ¨æ•°æ®ç§‘å­¦å’Œæœºå™¨å­¦ä¹ çš„å‘è¡Œä¸­æä¾›ï¼Œå³ä¸ä¸€äº›é€‰å®šçš„è½¯ä»¶åŒ…æ†ç»‘åœ¨ä¸€èµ·ã€‚å¯¹äºç»ƒä¹ ï¼Œæˆ‘ä»¬ä»¥åå°†ä½¿ç”¨å¸¦æœ‰Jupyterç¬”è®°æœ¬çš„Anacondaå‘è¡Œç‰ˆã€‚

ä¸€ä¸ªï¼ˆJupyter/IPythonï¼‰ç¬”è®°æœ¬æ˜¯ä¸€ä¸ªç”±è‹¥å¹²å•å…ƒæ ¼ç»„æˆçš„æ–‡ä»¶ã€‚æ¯ä¸ªå•å…ƒæ ¼å¯ä»¥åŒ…å«æ–‡æœ¬ã€æ•°å­¦ï¼ˆLaTeXï¼‰æˆ–Pythonä»£ç ï¼Œç„¶åç›´æ¥æ‰§è¡Œï¼ˆåƒåŸºäºæµè§ˆå™¨çš„REPLï¼‰ã€‚è¿™äº›ç¬”è®°æœ¬ï¼ˆ.ipynbï¼‰æ˜¯ä½œä¸ºJSONæ–‡æ¡£å®ç°çš„ã€‚
```

Dieses Buch ist auch eine Sammlung von Notebooks, die von Jupyter-Books zu einem zusammenhÃ¤ngenden Vorlesungsskript kompiliert werden.

-------------------------------------------------------------------

## 3.2. WeiterfÃ¼hrende Literatur
NatÃ¼rlich gibt es zu Python mittlerweile viel Material. Da die Sprache sehr lebendig ist, lohnt es sich, darauf zu achten, dass man mit python3 arbeitet. Die aktuellste Version, wÃ¤hrend diese Zeilen geschrieben werden, ist Python 3.10. Dieses Skript wurde grÃ¶ÃŸtenteils mit Python 3.8 erstellt.

```
æœ¬ä¹¦ä¹Ÿæ˜¯ç”±Jupyter-Bookså°†ç¬”è®°æœ¬æ±‡ç¼–æˆä¸€ä¸ªè¿è´¯çš„è®²ä¹‰çš„é›†åˆã€‚

3.2 è¿›ä¸€æ­¥é˜…è¯»
å½“ç„¶ï¼Œç°åœ¨å·²ç»æœ‰å¾ˆå¤šå…³äºPythonçš„ææ–™äº†ã€‚ç”±äºè¯¥è¯­è¨€éå¸¸æ´»æ³¼ï¼Œå› æ­¤å€¼å¾—ç¡®ä¿ä½ æ˜¯åœ¨ä½¿ç”¨python3å·¥ä½œã€‚å†™è¿™äº›è¡Œçš„æ—¶å€™ï¼Œæœ€æ–°çš„ç‰ˆæœ¬æ˜¯Python 3.10ï¼Œè¿™ä¸ªè„šæœ¬å¤§éƒ¨åˆ†æ˜¯ç”¨Python 3.8å†™çš„ã€‚
```

Eine sehr nÃ¼tzliche Resource ist PEP 8, der Python Style Guide, in dem die Ã¼blichen Code Konventionen festgehalten sind. Da Whitespace (EinrÃ¼ckung insb.) bei Python syntaktisch relevant ist, lohnt es sich, den Style Guide einmal zu Ã¼berfliegen.

PEP steht fÃ¼r Python Enhancement Proposal, das ist der Community-Prozess zur Weiterentwicklung der Sprache.

```
ä¸€ä¸ªéå¸¸æœ‰ç”¨çš„èµ„æºæ˜¯PEP 8ï¼Œå³Pythoné£æ ¼æŒ‡å—ï¼Œå®ƒåŒ…å«äº†é€šå¸¸çš„ä»£ç æƒ¯ä¾‹ã€‚ç”±äºç©ºç™½ï¼ˆå°¤å…¶æ˜¯ç¼©è¿›ï¼‰åœ¨Pythonä¸­ä¸è¯­æ³•æœ‰å…³ï¼Œæ‰€ä»¥å€¼å¾—ç•¥è¿‡é£æ ¼æŒ‡å—ã€‚

PEPæ˜¯Python Enhancement Proposalçš„ç¼©å†™ï¼Œå®ƒæ˜¯ç¤¾åŒºè¿›ä¸€æ­¥å‘å±•è¯¥è¯­è¨€çš„è¿‡ç¨‹ã€‚

```

Die offizielle Dokumentation der Sprache ist ausfÃ¼hrlich und sehr nÃ¼tzlich. So kann man fÃ¼r eine bestimmte Aufgabe oft im Python Modulindex ein mitgeliefertes Modul finden, dass diese Aufgabe erfÃ¼llen kann.

FÃ¼r erfahrene Programmierer*innen wurde das frei verfÃ¼gbare Dive Into Python geschrieben. Sehr ausfÃ¼hrlich Ã¼ber Installation, Konfiguration, IDEs, Coding Styles und Common Gotchas kann man im frei verfÃ¼gbaren Hitchhikerâ€™s Guide to Python nachlesen. Eine freundliche langsame EinfÃ¼hrung in Python fÃ¼r Wissenschaftler*innen gibt es mit der Whirlwind Tour of Python (auch wenn man das PDF unter CC0-Lizenz des bei Oâ€™Reilly erschienenen Buchs mittlerweile etwas suchen muss).

```
è¯¥è¯­è¨€çš„å®˜æ–¹æ–‡ä»¶å¾ˆè¯¦ç»†ï¼Œéå¸¸æœ‰ç”¨ã€‚ä¾‹å¦‚ï¼Œå¯¹äºä¸€ä¸ªç‰¹å®šçš„ä»»åŠ¡ï¼Œä½ é€šå¸¸å¯ä»¥åœ¨ Python æ¨¡å—ç´¢å¼•ä¸­æ‰¾åˆ°ä¸€ä¸ªå¯ä»¥å®Œæˆè¯¥å·¥ä½œçš„æ¨¡å—ã€‚

å¯¹äºæœ‰ç»éªŒçš„ç¨‹åºå‘˜ï¼Œç¼–å†™äº†å…è´¹æä¾›çš„Dive Into Pythonã€‚å…³äºå®‰è£…ã€é…ç½®ã€IDEã€ç¼–ç é£æ ¼å’Œå¸¸è§çš„é—®é¢˜ï¼Œå¯ä»¥åœ¨å…è´¹æä¾›çš„ã€ŠPythonæ­è½¦æŒ‡å—ã€‹ä¸­æ‰¾åˆ°éå¸¸è¯¦ç»†çš„ä¿¡æ¯ã€‚åœ¨ã€ŠPythonæ—‹é£ä¹‹æ—…ã€‹ä¸­ä¸ºç§‘å­¦å®¶ä»¬æä¾›äº†ä¸€ä¸ªå‹å¥½çš„ç¼“æ…¢çš„Pythonä»‹ç»ï¼ˆå³ä½¿ä½ ä¸å¾—ä¸åœ¨CC0è®¸å¯ä¸‹æœç´¢ç”±O'Reillyå‡ºç‰ˆçš„ä¹¦çš„PDFï¼‰ã€‚
```

Auf Deutsch ist unter anderem der Python-Kurs von Bernd Klein gut und aktuell.

Wer gern etwas Ã¼ber die skurrileren Seiten (auch der Implementierung) lernen mÃ¶chte, ist mit WTF Python gut bedient.

## 3.3. Wichtigstes
Um die Dokumentation und den Code von Python-Modulen schnell zu verstehen, muss man syntaktische Eigenarten und Konzepte von Python kennen. Hier sind einige der wichtigsten zusammengestellt.

```
åœ¨å¾·è¯­æ–¹é¢ï¼ŒBernd Kleinç­‰äººçš„Pythonè¯¾ç¨‹å¾ˆå¥½ï¼Œè€Œä¸”æ˜¯æœ€æ–°çš„ã€‚

å¦‚æœä½ æƒ³äº†è§£ä¸€äº›æ›´ç¦»å¥‡çš„æ–¹é¢ï¼ˆåŒ…æ‹¬å®ç°ï¼‰ï¼ŒWTF Pythonæ˜¯ä¸é”™çš„ã€‚

3.3 æœ€é‡è¦çš„
ä¸ºäº†å¿«é€Ÿç†è§£Pythonæ¨¡å—çš„æ–‡æ¡£å’Œä»£ç ï¼Œä½ éœ€è¦äº†è§£Pythonçš„å¥æ³•ç‰¹ç‚¹å’Œæ¦‚å¿µã€‚è¿™é‡Œæœ‰ä¸€äº›æœ€é‡è¦çš„ã€‚
```
### 3.3.1. Datentypen
Zahlen werden entweder als Integer (int) oder als Floating Point Number (float) reprÃ¤sentiert, und es gibt sogar komplexe Zahlen (complex).

```
3.3.1 æ•°æ®ç±»å‹
æ•°å­—å¯ä»¥ç”¨æ•´æ•°ï¼ˆintï¼‰æˆ–æµ®ç‚¹æ•°ï¼ˆfloatï¼‰è¡¨ç¤ºï¼Œç”šè‡³è¿˜æœ‰å¤æ•°ï¼ˆcomplexï¼‰ã€‚
```

```python
print("23 ist", type(23), "und 23.0 ist", type(23.0))
print("und 23+2j ist", type(23+2j))
print("Addieren wir int und floats gibt's", type(23+23.0))
print("Division von Ganzzahlen ergibt float, also ist 5/2 =", 5/2)
print("Wenn wir das nicht wollen, kÃ¶nnen wir rechnen 5//2 =", 5//2)
```

```python
23 ist <class 'int'> und 23.0 ist <class 'float'>
und 23+2j ist <class 'complex'>
Addieren wir int und floats gibt's <class 'float'>
Division von Ganzzahlen ergibt float, also ist 5/2 = 2.5
Wenn wir das nicht wollen, kÃ¶nnen wir rechnen 5//2 = 2
```
Strings (Zeichenketten) sind grundsÃ¤tzlich Unicode, wobei auf UTF-8 zurÃ¼ckgegriffen wird, wenn nichts anderes spezifiziert wird. Das bedeutet heutzutage im Alltag meist, dass die Quelltexte auch mit Umlauten und Akzentzeichen klarkommen, aber bei relativ alten Dateien (gerade aus der Python2-Ã„ra) evtl. das Encoding geÃ¤ndert bzw. spezifiziert werden muss. Uns wird das nicht beschÃ¤ftigen.

Dictionaries sind Abbildungen mit endlichem Definitionsbereich, man notiert z.B. den mathematischen Sachverhalt ğ‘“ âˆ¶ {ğ‘, ğ‘} â†’ â„, ğ‘ â†¦ 1, ğ‘ â†¦ 2 und ğ‘“(ğ‘) = 1 als

```
å­—ç¬¦ä¸²å§‹ç»ˆæ˜¯Unicodeï¼Œå¦‚æœæ²¡æœ‰æŒ‡å®šå…¶ä»–å†…å®¹ï¼Œåˆ™ä½¿ç”¨UTF-8ã€‚ç°åœ¨ï¼Œè¿™é€šå¸¸æ„å‘³ç€æºæ–‡æœ¬ä¹Ÿå¯ä»¥å¤„ç† umlauts å’Œé‡éŸ³å­—ç¬¦ï¼Œä½†å¯¹äºç›¸å¯¹è¾ƒè€çš„æ–‡ä»¶ï¼ˆå°¤å…¶æ˜¯ Python2 æ—¶ä»£çš„æ–‡ä»¶ï¼‰ï¼Œå¯èƒ½å¿…é¡»æ”¹å˜æˆ–æŒ‡å®šç¼–ç ã€‚æˆ‘ä»¬å°†ä¸å…³å¿ƒè¿™ä¸ªé—®é¢˜ã€‚

è¯å…¸æ˜¯å…·æœ‰æœ‰é™å®šä¹‰åŸŸçš„æ˜ å°„ï¼Œä¾‹å¦‚ï¼Œäººä»¬æ³¨æ„åˆ°æ•°å­¦äº‹å® ğ‘“ âˆ¶ {ğ‘, ğ‘}ã€‚â†’ â„, â†¦ 1, ğ‘ â†¦ 2 å’Œ ğ‘“(ğ‘) = 1ï¼Œå› ä¸º
```

```python
f = {"a":1, "b":2}
if(f == dict(a=1, b=2)):
    print("Syntaktischer Zucker erlaubt es gelegentlich, auf AnfÃ¼hrungszeichen zu verzichten.")
if(f["a"] == 1):
    print("Alles wie geplant")
print(f, "is a", type(f))
try:
    print(f["c"])
    print("an diese Stelle kommt der Interpreter nie")
except KeyError:
    f["c"] = "Man muss aufpassen, wo eckige und wo runde Klammern hinkommen"
finally:
    print(f["c"]) # aber jetzt!
```

```python
Syntaktischer Zucker erlaubt es gelegentlich, auf AnfÃ¼hrungszeichen zu verzichten.
Alles wie geplant
{'a': 1, 'b': 2} is a <class 'dict'>
Man muss aufpassen, wo eckige und wo runde Klammern hinkommen
```
Tupel sind lÃ¤ngenfixierte unverÃ¤nderliche Listen, also z.B. Paare oder Tripel. Achtung: die Addition ist nicht elementweise, sondern eine Listenkonkatenation, die ein neues (vom alten verschiedenes) Tupel erzeugt:

```
### å…ƒç»„

æ˜¯é•¿åº¦å›ºå®šçš„ä¸å˜çš„åˆ—è¡¨ï¼Œä¾‹å¦‚æˆå¯¹æˆ–æˆä¸‰çš„åˆ—è¡¨ã€‚æ³¨æ„ï¼šåŠ æ³•ä¸æ˜¯æŒ‰å…ƒç´ è®¡ç®—çš„ï¼Œè€Œæ˜¯é€šè¿‡åˆ—è¡¨è¿æ¥æ¥åˆ›å»ºä¸€ä¸ªæ–°å…ƒç»„ï¼ˆä¸æ—§å…ƒç»„ä¸åŒï¼‰ã€‚
```

```python
paar = (2,3)
print(paar, "is a", type(paar), "of length", len(paar))
tripel = (4,5,6)
print(paar, "+", tripel, "=", paar+tripel)
print((0,1), "* 3 =", (0,1)*3)
```

```python
(2, 3) is a <class 'tuple'> of length 2
(2, 3) + (4, 5, 6) = (2, 3, 4, 5, 6)
(0, 1) * 3 = (0, 1, 0, 1, 0, 1)
```
### Mengen
 sind ungeordnete Listen, auch die notiert man mit geschweiften Klammern:

```
é›†åˆ
æ˜¯æ— åºçš„åˆ—è¡¨ï¼Œä¹Ÿæ˜¯ç”¨å¤§æ‹¬å·å†™çš„ã€‚
```

```python
Menge = {3,2,1}
print(Menge)
Nochnemenge = set((2,3,1))
Menge == Nochnemenge
```

```python
{1, 2, 3}
```

```python
True

```
### Listen 
sind geordnet und kÃ¶nnen verlÃ¤ngert werden. Unter der Haube verwendet Python je nach LÃ¤nge und Implementierung des jeweiligen Interpreters oder Compilers dann einen Array mit fester LÃ¤nge (der dann notfalls getauscht wird, wenn die Liste wÃ¤chst) oder eine linked List oder so. Als Anwender merkt man davon nichts und es ist fÃ¼r Performancefragen in der Regel irrelevant. Eine list comprehension ist eine Art, Ã¼ber eine Liste zu iterieren um eine weitere zu erstellen.

```
åˆ—è¡¨
æ˜¯æœ‰é¡ºåºçš„ï¼Œå¯ä»¥æ‰©å±•ã€‚åœ¨å¼•æ“ç›–ä¸‹ï¼Œæ ¹æ®å„è‡ªçš„è§£é‡Šå™¨æˆ–ç¼–è¯‘å™¨çš„é•¿åº¦å’Œå®ç°ï¼ŒPython ç„¶åä½¿ç”¨ä¸€ä¸ªå›ºå®šé•¿åº¦çš„æ•°ç»„ï¼ˆå½“åˆ—è¡¨å¢é•¿æ—¶ï¼Œå¦‚æœæœ‰å¿…è¦ï¼Œä¼šè¿›è¡Œäº¤æ¢ï¼‰æˆ–ä¸€ä¸ªé“¾æ¥åˆ—è¡¨æˆ–å…¶ä»–ä¸œè¥¿ã€‚ä½œä¸ºä¸€ä¸ªç”¨æˆ·ï¼Œä½ ä¸ä¼šæ³¨æ„åˆ°è¿™ä¸€ç‚¹ï¼Œè€Œä¸”è¿™é€šå¸¸ä¸æ€§èƒ½é—®é¢˜æ— å…³ã€‚åˆ—è¡¨ç†è§£æ˜¯å¯¹ä¸€ä¸ªåˆ—è¡¨è¿›è¡Œè¿­ä»£ä»¥åˆ›å»ºå¦ä¸€ä¸ªåˆ—è¡¨çš„ä¸€ç§æ–¹å¼ã€‚
```

```python
liste = [3,1,4,1,5,9]
if(5 in liste):
    print(liste, "vom Typ", type(liste), "hat LÃ¤nge", len(liste))
print(liste + [-1,-1,-1])
liste += [0]
print(liste)
tripel = (1,2,3)
print(list(tripel))
# hier kommt die list comprehension:
neue = [x+2 for x in liste]
print(neue)
```

```python
[3, 1, 4, 1, 5, 9] vom Typ <class 'list'> hat LÃ¤nge 6
[3, 1, 4, 1, 5, 9, -1, -1, -1]
[3, 1, 4, 1, 5, 9, 0]
[1, 2, 3]
[5, 3, 6, 3, 7, 11, 2]
```

### Slicing
 nennt man es, wenn man einen Teil einer Liste in Python auswÃ¤hlt mit der Doppelpunkt-Syntax.

```
åˆ‡ç‰‡
æ˜¯æŒ‡åœ¨Pythonä¸­ä½¿ç”¨å†’å·è¯­æ³•é€‰æ‹©ä¸€ä¸ªåˆ—è¡¨çš„ä¸€éƒ¨åˆ†ã€‚
```

```python
zahlen = range(0,10)  # Achtung, geht mit 0 los, 10 ist nicht dabei.
print(zahlen, type(zahlen))
zahlen = list(zahlen)
print(zahlen, type(zahlen))
print(zahlen[1:9]) # hier ist auch die 9 nicht dabei.
print(zahlen[:5] + zahlen[5:])
print("es geht auch negativ:", zahlen[-1:])
print(zahlen[:-1] + zahlen[-1:])
```

```python
range(0, 10) <class 'range'>
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] <class 'list'>
[1, 2, 3, 4, 5, 6, 7, 8]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
es geht auch negativ: [9]
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
```

### Generatoren 
sind Objekte, die Listen in einer Hinsicht verallgemeinern: man kann sich das nÃ¤chste Element geben lassen. Es muss aber keine ganze Liste im Speicher gehalten werden (und auch nicht im voraus berechnet werden), daher sind Generator-AusdrÃ¼cke an vielen Stellen die richtige Wahl fÃ¼r Datenverarbeitungs-Pipelines innerhalb Python. Man kann jede Liste und jedes Tupel als Generator verwenden und auch die range-Objekte sind Generatoren.

```
ç”Ÿæˆå™¨
æ˜¯ä»¥ä¸€ç§æ–¹å¼æ¦‚æ‹¬åˆ—è¡¨çš„å¯¹è±¡ï¼šä½ å¯ä»¥è¢«èµ‹äºˆä¸‹ä¸€ä¸ªå…ƒç´ ã€‚ç„¶è€Œï¼Œä¸éœ€è¦åœ¨å†…å­˜ä¸­ä¿å­˜æ•´ä¸ªåˆ—è¡¨ï¼ˆä¹Ÿä¸éœ€è¦æå‰è®¡ç®—ï¼‰ï¼Œæ‰€ä»¥ç”Ÿæˆå™¨è¡¨è¾¾å¼åœ¨å¾ˆå¤šåœ°æ–¹æ˜¯Pythonä¸­æ•°æ®å¤„ç†ç®¡é“çš„æ­£ç¡®é€‰æ‹©ã€‚ä½ å¯ä»¥ä½¿ç”¨ä»»ä½•åˆ—è¡¨æˆ–å…ƒç»„ä½œä¸ºç”Ÿæˆå™¨ï¼Œè€Œä¸”èŒƒå›´å¯¹è±¡ä¹Ÿæ˜¯ç”Ÿæˆå™¨ã€‚
```

```python
gen = (x + 2 for x in range(0,5))
print(gen, "hat den Typ", type(gen))
# und erst jetzt wird die Berechnung ausgefÃ¼hrt:
for x in gen:
    print(x)
```

```python
<generator object <genexpr> at 0x7f12b85e4660> hat den Typ <class 'generator'>
2
3
4
5
6
```

## 3.3.2. Gleichheit und IdentitÃ¤t
Wertgleichheit wird mit dem Operator == geprÃ¼ft, Referenzgleichheit mit dem SchlÃ¼sselwort is, das entspricht einer Wertgleichheit der ids.

```
3.3.2 å¹³ç­‰å’Œèº«ä»½
ç”¨è¿ç®—ç¬¦==æ£€æŸ¥å€¼çš„ç›¸ç­‰ï¼Œç”¨å…³é”®å­—isæ£€æŸ¥å¼•ç”¨çš„ç›¸ç­‰ï¼Œè¿™ç›¸å½“äºidçš„å€¼ç›¸ç­‰ã€‚
```

```python
print(123 == 121 + 2)
a = [1,2,3]
b = a[:] # Kopie
print(id(a) == id(b))
print(a is b)
print(a is [1,2,3])
print(a == b)
```

```python
True
False
False
False
True
```

TypenzugehÃ¶rigkeit prÃ¼fen wir mit der Methode 
## isinstance.

```
æˆ‘ä»¬ç”¨isinstanceæ–¹æ³•æ£€æŸ¥ç±»å‹å…³è”ã€‚
```

```python
print(isinstance("a", str))
print(isinstance(123, bool))
print(type(123))
print(isinstance(123, object))
```

```python
True
False
<class 'int'>
True
```

Noch schwÃ¤cher als == ist ein Vergleich der darstellenden Strings (das ist etwas anderes als eine Typenkonversion zum Typ str). Dabei soll repr() einen mÃ¶glichst eindeutigen String liefern, wÃ¤hrend str() einen mÃ¶glichst lesbaren String liefern soll. Oft lÃ¤sst sich der repr-String als Python-Code evaluieren mit eval, der eine Kopie des Objekts erzeugt.

```
æ¯”==æ›´å¼±çš„æ˜¯ä»£è¡¨å­—ç¬¦ä¸²çš„æ¯”è¾ƒï¼ˆè¿™ä¸ç±»å‹è½¬æ¢ä¸ºstrç±»å‹ä¸åŒï¼‰ã€‚è¿™é‡Œï¼Œrepr()åº”è¯¥è¿”å›ä¸€ä¸ªå°½å¯èƒ½å”¯ä¸€çš„å­—ç¬¦ä¸²ï¼Œè€Œstr()åº”è¯¥è¿”å›ä¸€ä¸ªå°½å¯èƒ½å¯è¯»çš„å­—ç¬¦ä¸²ã€‚é€šå¸¸æƒ…å†µä¸‹ï¼Œreprå­—ç¬¦ä¸²å¯ä»¥ä½œä¸ºPythonä»£ç ç”¨evalè¿›è¡Œè¯„ä¼°ï¼Œå®ƒå¯ä»¥åˆ›å»ºä¸€ä¸ªå¯¹è±¡çš„å‰¯æœ¬ã€‚
```

```python
a = dict(key1=1, key2=2)
b = {"key1":'1', "key2":'2'}
print("echt verschiedene dict Objekte haben verschiedene ReprÃ¤sentationen:")
print("(", a, "==", b, ") =", a == b)
print("aber bei dict Objekten ist str() das gleiche wie repr()")
print("(", repr(a), "==", str(a), ") = ", repr(a) == str(a))

c = eval(repr(a))
print(c)

print(str(3) == str("3"))
print(repr(3) == repr("3"))
print(repr(3), "!=", repr("3"))
```

```python
echt verschiedene dict Objekte haben verschiedene ReprÃ¤sentationen:
( {'key1': 1, 'key2': 2} == {'key1': '1', 'key2': '2'} ) = False
aber bei dict Objekten ist str() das gleiche wie repr()
( {'key1': 1, 'key2': 2} == {'key1': 1, 'key2': 2} ) =  True
{'key1': 1, 'key2': 2}
True
False
3 != '3'
```
## 3.3.3. Objektorientierte Programmierung

```
3.3.3 é¢å‘å¯¹è±¡çš„ç¼–ç¨‹

```

```python
class meineKlasse():
    def meineMethode(self, methodisch):
        print(methodisch, self)
    
    def __init__(self):
        self.attribut = 123
        
    def __repr__(self):
        return str(self.attribut)
    
x = meineKlasse()
x.meineMethode("test")
print(type(x))
isinstance(x, object)
```

```python
test 123
<class '__main__.meineKlasse'>
```
```python
test 123
<class '__main__.meineKlasse'>
```
Der Polymorphismus geht so weit, dass man oft nicht wissen muss, ob eine Variable nun auf eine Klasse oder eine Methode verweist - wenn es Callable ist, kann man () dahinter hÃ¤ngen und bekommt etwas.

## 3.3.4. Privat und Ã–ffentlich
Es gibt (im Gegensatz zu z.B. Java) in Python keine MÃ¶glichkeit, etwas zu verstecken (private, protected, etc.) auÃŸer durch Konvention: wenn ein Objektattribut oder eine Methode mit einem einzelnen Underscore vorangestellt gekennzeichnet ist, soll sie als â€privatâ€œ betrachtet werden

```
å¤šæ€æ€§å‘å±•åˆ°ç°åœ¨ï¼Œä½ å¾€å¾€ä¸éœ€è¦çŸ¥é“ä¸€ä¸ªå˜é‡æ˜¯æŒ‡ä¸€ä¸ªç±»è¿˜æ˜¯ä¸€ä¸ªæ–¹æ³•--å¦‚æœå®ƒæ˜¯å¯è°ƒç”¨çš„ï¼Œä½ å¯ä»¥åœ¨å®ƒåé¢åŠ ä¸Šï¼ˆï¼‰ï¼Œç„¶åå¾—åˆ°ä¸€äº›ä¸œè¥¿ã€‚

3.3.4 ç§äººå’Œå…¬å…±
åœ¨Pythonä¸­æ²¡æœ‰åŠæ³•ï¼ˆä¸Javaä¸åŒï¼‰éšè—æŸäº›ä¸œè¥¿ï¼ˆç§æœ‰çš„ã€å—ä¿æŠ¤çš„ç­‰ç­‰ï¼‰ï¼Œé™¤äº†æƒ¯ä¾‹ï¼šå¦‚æœä¸€ä¸ªå¯¹è±¡å±æ€§æˆ–æ–¹æ³•çš„å‰ç¼€æ˜¯ä¸€ä¸ªä¸‹åˆ’çº¿ï¼Œå®ƒå°±è¢«ç§°ä¸º "ç§æœ‰"ã€‚
```

## 3.3.5. Dictionaries und Tupel sind Ã¼berall
Tupel lassen sich auspacken:

```
3.3.5 å­—å…¸å’Œå›¾å…ƒæ— å¤„ä¸åœ¨
å›¾å…ƒå¯ä»¥è¢«è§£åŒ…ã€‚
```

```python
t = (1, 2, 3)
a, b, c = t
print(t, a, b, c)
```
```python
(1, 2, 3) 1 2 3
```
In einer Methodendeklaration gibt es die MÃ¶glichkeit, beliebig viele Positionsargumente zuzulassen:

```
åœ¨ä¸€ä¸ªæ–¹æ³•å£°æ˜ä¸­ï¼Œæœ‰å¯èƒ½å…è®¸ä»»ä½•æ•°é‡çš„ä½ç½®å‚æ•°ã€‚
```

```python
def methode(*args):
    return args

methode()
print(methode(1,2,3,"vier"))

def neuemethode(argmusssein, *args):
    return args

print(neuemethode(1,2,3,"vier"))
```

```python
(1, 2, 3, 'vier')
(2, 3, 'vier')
```

```python
try:
    neuemethode()
except TypeError as e:
    print(e)
```

```python
neuemethode() missing 1 required positional argument: 'argmusssein'
```

Ebenso kann man mit SchlÃ¼sselwortargumenten umgehen:

```
ä½ å¯ä»¥ç”¨åŒæ ·çš„æ–¹æ³•æ¥å¤„ç†å…³é”®å­—å‚æ•°ã€‚
```

```python
def methode(**kwargs):
    return kwargs

methode()
print(methode(key="value"))

try:
    methode("123")
except TypeError as e:
    print(e)
```

```python
{'key': 'value'}
methode() takes 0 positional arguments but 1 was given
```
Insgesamt kann man eine Folge von zwingenden Positionsargumenten, eine Folge von spezifizierten SchlÃ¼sselwortargumenten und beliebiege weitere zulassen

```
æ€»çš„æ¥è¯´ï¼Œæˆ‘ä»¬å¯ä»¥å…è®¸ä¸€è¿ä¸²å¼ºåˆ¶æ€§çš„ä½ç½®å‚æ•°ï¼Œä¸€è¿ä¸²æŒ‡å®šçš„å…³é”®å­—å‚æ•°ï¼Œä»¥åŠä»»ä½•æ•°é‡çš„å…¶ä»–å‚æ•°

```

```python
def methode(posarg, posarg2, *args, kwarg=None, kwarg2=True, **kwargs):
    return args, kwargs

#methode() # <--- geht nicht

methode(1, 2, 3, 4, 5, kwarg2=False, kwarg3="test")
```

```python
((3, 4, 5), {'kwarg3': 'test'})
```

Um direkt ein ganzes dict-Objekt als SchlÃ¼sselwortargumente zu Ã¼bergeben, kann man dies entpacken (und genau so Tupel):

```
ä¸ºäº†ç›´æ¥ä¼ é€’æ•´ä¸ªdictå¯¹è±¡ä½œä¸ºå…³é”®å­—å‚æ•°ï¼Œä½ å¯ä»¥è§£å¼€è¿™ä¸ªï¼ˆä»¥åŠåƒè¿™æ ·çš„tuplesï¼‰ã€‚
```

```python
args = (1, 2, 3, 4, 5)
kwargs = {"kwarg2": False, "kwarg3": "test"}
print(methode(*args, **kwargs))

print(args)
print(*args)
```

```python
((3, 4, 5), {'kwarg3': 'test'})
(1, 2, 3, 4, 5)
1 2 3 4 5
```
Auch Objektattribute werden in einem dict verwaltet:

```
å¯¹è±¡çš„å±æ€§ä¹Ÿåœ¨ä¸€ä¸ªdictä¸­ç®¡ç†ã€‚
```

```python
class neueKlasse():
    def __init__(self):
        self.x = 1
        self.y = 2
        
neuesObjekt = neueKlasse()
print(neuesObjekt.__dict__)
neuesObjekt.__dict__["z"] = 3
neuesObjekt.z == 3
```

```python
{'x': 1, 'y': 2}
```

```python
True
```
